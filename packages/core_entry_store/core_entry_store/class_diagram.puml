@startuml

class ValueHandler<Event, T> {
  +valueHandler: T Function(T, Event)
}

class BlocBase<ValueState<Event, T>> {
}

class ValueImpl<Event, T> {
  -valueHandler: ValueHandler
  -_onError: Function
  -subscription: StreamSubscription
  -_stateStreamableSource: _ValueStreamableSource
  +ValueImpl(): void
  +start(): void
  +apply(effect: JournalHeadEffect): void
  +onError(error: Object, stackTrace: StackTrace): void
  +close(): Future
}

class _ValueStreamableSource<T> {
  -_stream: Stream
  -subscription: StreamSubscription
  +start(): void
  +close(): Future
}

class ValueState<Event, T> {
  -value: T
  +apply(effect: JournalHeadEffect, valueHandler: ValueHandler): ValueState
  +_applyEvents(previous: T, events: Iterable, valueHandler: ValueHandler): T
}

class EntryStoreFactory {
  -idFactory: IdFactory
  -entryRefLogFactory: EntryRefLogFactory
  +create(path: String, headRef: String, eventConverter: JsonEventConverter): EntryStore
}

class EntryStore<Event> {
  -_delegate: EntryStoreDelegate
  +appendEntry(entry: Entry, instanceEntryRef: HeadEntryRef): Future
  +forwardHeadEntryRef(previous: EntryRef, next: HeadEntryRef): Future
  +initialize(rootEntryIfEmpty: Entry): Future
  +resetHeadEntryRef(previous: EntryRef, next: HeadEntryRef): Future
  +updateMainEntryRef(previous: EntryRef, next: EntryRef): Future
}

class EntryStoreDelegate<Event> {
}

class IdFactory {
  -_create: Function
  +create(): String
}

class DateTimeConverter {
  +fromJson(value: int): DateTime
  +toJson(value: DateTime): int
}

class AutoIdGenerator {
  +autoId(): String
}

class Application<Request, View> {
  +execute(request: Request): void
}

class ApplicationImpl<Request, RequestHandle, Event, View> {
  -_processor: ApplicationProcessor
  -_journal: Journal
  -_requestHandleFactory: Function
  +ApplicationImpl(): void
}

class ApplicationProcessor<Request, RequestHandle, Event, View> {
}

class EntryRefLog {
  +fromJson(json: Map): EntryRefLog
}

class EntryRefLogFactory {
  -_dateTimeFactory: DateTimeFactory
  +append(previous: EntryRef, next: EntryRef): EntryRefLog
  +forward(previous: EntryRef, next: EntryRef): EntryRefLog
  +reset(previous: EntryRef, next: EntryRef): EntryRefLog
}

ValueImpl *-- ValueHandler
ValueImpl *-- BlocBase
ValueImpl o-- _ValueStreamableSource
ValueState o-- ValueHandler
EntryStore *-- EntryStoreDelegate
EntryStoreFactory o-- IdFactory
EntryStoreFactory o-- EntryRefLogFactory
ApplicationImpl *-- ApplicationProcessor
ApplicationImpl *-- Journal
EntryRefLogFactory *-- DateTimeFactory


title Journal Diagram

class JournalState<Event> {
  +JournalState.initial({Entry<Event> rootEntry, EntryRef upstreamEntryRef, EntryRef instanceEntryRef})
  +JournalState({EntryRef upstreamEntryRef, EntryRef instanceEntryRef, Map<EntryRef, Entry<Event>> entries, DirectedGraph<Entry<Event>> graph, Set<EntryRef> pending})
}

class JournalEvent<Request, Handle, Event> {
  +JournalEvent.request({RequestEffect<Event> Function(EntryRef) handler})
  +JournalEvent.mainRefUpdate({EntryRef entryRef})
  +JournalEvent.entryCollectionUpdate({Iterable<EntrySnapshot<Event>> snapshots})
}

class JournalImpl<Request, RequestHandle, Event> {
  -EntryStore<Event> _entryStore
  -EntryRefFactory _entryRefFactory
  +JournalImpl(super.initialState, {EntryRefFactory EntryRefFactory, EntryStore<Event> entryStore})
  +void execute(RequestEffect<Event> Function(RequestHandle p1) handler)
}


class JournalHeadEffect<Event> {
  +JournalHeadEffect.append(EntryRef start, Entry<Event> entry)
  +JournalHeadEffect.forward(EntryRef start, Iterable<Entry<Event>> entries)
  +JournalHeadEffect.merge(EntryRef start, Iterable<EntryRef> base, Iterable<Entry<Event>> entries, {Entry<Event> entry})
  +JournalHeadEffect.none()
}

class DateTimeFactory {
  +DateTimeFactory(DateTime Function() _create)
  +DateTime create()
}

class EntryRef {
  +EntryRef(String value)
  +EntryRef.fromJson(Map<String, dynamic> json)
}

class HeadEntryRef {
  +HeadEntryRef(EntryRef entryRef, @DateTimeConverter() DateTime createdAt)
  +HeadEntryRef.fromJson(Map<String, dynamic> json)
}

class EntryRefFactory {
  +EntryRefFactory(IdFactory _idFactory)
  +EntryRef create()
}

class EntryRefFactory {
  +EntryRefFactory(DateTimeFactory _dateTimeFactory)
  +HeadEntryRef create(EntryRef entryRef)
}

class EntrySnapshot<Event> {
  +EntrySnapshot(Entry<Event> entry, {bool isPending})
}

class RequestEffect<EventEnvelope> {
  +RequestEffect.persist({Iterable<EventEnvelope> events, void Function()? onComplete})
  +RequestEffect.none({void Function()? onComplete})
  +RequestEffect.fail({String? message})
}

class JsonEntryConverter<Event> {
  +JsonEntryConverter(JsonEventConverter<Event> jsonEventConverter)
  +Entry<Event> Function(Object? json) fromJsonObject
  +Map<String, dynamic> Function(Entry<Event>) toJsonObject
}

class JsonEventConverter<Event> {
  +JsonEventConverter(Event Function(Map<String, dynamic>) fromJsonObject, Map<String, dynamic> Function(Event) toJsonObject)
}

class Entry<Event> {
  +Entry.newRoot({DateTime? createdAt})
  +Entry({EntryRef ref, Iterable<EntryRef> refs, Iterable<Event> events, @DateTimeConverter() DateTime createdAt})
  +Entry.fromJson(Map<String, dynamic> json, Event Function(Object? json) fromJsonEvent)
  +Map<String, dynamic> toJson(Object? Function(Event) eventToJson)
  +int compareTo(Entry<Event> other)
}

JournalState o-- Entry
JournalState o-- EntryRef
JournalState o-- DirectedGraph
JournalState o-- "Map<EntryRef, Entry<Event>>" Entries
JournalState o-- "Set<EntryRef>" Pending

JournalEvent o-- RequestEffect
JournalEvent o-- EntryRef
JournalEvent o-- EntrySnapshot


title Journal Diagram

class Journal<Event> {
  +void execute(RequestEffect<Event> Function(RequestHandle) handler)
}

JournalImpl --|> Journal

DateTimeFactory <.. EntryRefFactory : uses
DateTimeFactory <.. EntryRefFactory : uses

class IdFactory {
}

EntryRefFactory -- IdFactory

class Entry<Event> {
  +Entry.newRoot({DateTime? createdAt})
  +Entry({EntryRef ref, Iterable<EntryRef> refs, Iterable<Event> events, @DateTimeConverter() DateTime createdAt})
  +Entry.fromJson(Map<String, dynamic> json, Event Function(Object? json) fromJsonEvent)
  +Map<String, dynamic> toJson(Object? Function(Event) eventToJson)
  +int compareTo(Entry<Event> other)
}

class JsonObject {
}

JsonEntryConverter o-- JsonEventConverter
JsonEntryConverter o-- Entry
JsonEventConverter o-- JsonObject
JsonObject -- Entry

ValueImpl *-- ValueState
EntryStore *-- Entry
ApplicationImpl *-- Application
ApplicationImpl *-- Journal
JournalImpl *-- JournalState
JournalImpl *-- EntryStore
JournalImpl *-- EntryRefFactory
EntryStoreFactory *-- EntryStore

@enduml
